<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IPTV Player</title>
  <link href="https://vjs.zencdn.net/7.17.0/video-js.css" rel="stylesheet" />
  <script src="https://vjs.zencdn.net/7.17.0/video.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-hls-quality-selector@1.1.4/dist/videojs-hls-quality-selector.min.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@theonlyducks/videojs-zoom/dist/videojs-zoom.css">
  <script src="https://cdn.jsdelivr.net/npm/@theonlyducks/videojs-zoom/dist/videojs-zoom.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      display: flex;
      flex-direction: column; /* Stack controls over player */
      height: 100vh;
      overflow: hidden;
    }

    #controls {
      padding: 15px;
      background: #282828;
      display: flex;
      flex-direction: column; /* Arrange groups vertically */
      gap: 10px;
      border-bottom: 1px solid #3a3a3a;
    }

    .input-group,
    .filter-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      width: 100%;
    }

    #playlistUrlInput {
      flex-grow: 1;
      min-width: 200px;
    }

    #categoryFilter,
    #languageFilter {
      flex-grow: 1;
      min-width: 150px;
      height: 40px; /* Standard height for single-line selects */
    }

    #playlistUrlInput,
    #categoryFilter,
    #languageFilter {
      padding: 10px 12px;
      border: 1px solid #444;
      background: #3a3a3a;
      color: #e0e0e0;
      border-radius: 5px;
      font-size: 1em;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }

    #playlistUrlInput::placeholder {
      color: #bbb;
    }

    #loadPlaylistBtn,
    #toggleListBtn {
      padding: 10px 20px;
      background: #007bff;
      border: none;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.2s ease;
    }

    #loadPlaylistBtn:hover {
      background: #0056b3;
    }

    #video {
      width: 100%;
      flex-grow: 1;
      background: #000;
    }

      #list.hidden {
        transform: translateX(-110%);
      }

      #main-content {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      /* Floating list INSIDE the player */
      #list {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 200px; /* Slightly reduced width */
        height: calc(100% - 60px); /* Slightly reduced height */
        overflow-y: auto;
        box-sizing: border-box;
        background: rgba(34, 34, 34, 0.92);
        border: 1px solid #3a3a3a;
        border-radius: 8px;
        padding: 10px;
        z-index: 10;
        box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        transition: transform 0.3s ease-in-out;
        transform: translateX(0);
      }

      /* Custom Scrollbar for #list */
      #list::-webkit-scrollbar {
        width: 8px; /* width of the entire scrollbar */
      }

      #list::-webkit-scrollbar-track {
        background: #222; /* color of the tracking area */
      }

      #list::-webkit-scrollbar-thumb {
        background-color: #555; /* color of the scroll thumb */
        border-radius: 4px; /* roundness of the scroll thumb */
        border: 2px solid #222; /* creates padding around scroll thumb */
      }

      #player-container {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        position: relative; /* Allow floating overlays */
      }

      /* EPG Now/Next overlay */
      #epgOverlay {
        position: absolute;
        right: 10px;
        bottom: 10px;
        max-width: 38%;
        background: rgba(0,0,0,0.55);
        color: #eee;
        padding: 8px 10px;
        border-radius: 6px;
        border: 1px solid rgba(255,255,255,0.1);
        font-size: 0.9em;
        line-height: 1.35;
        z-index: 12;
      }
      #epgOverlay .title { font-weight: 600; color: #fff; }
      #epgOverlay .time { color: #ccc; font-size: 0.85em; }
      #epgOverlay .sep { opacity: 0.6; margin: 0 6px; }

      #controls {
        padding: 15px;
        background: #282828;
        display: flex;
        flex-direction: column; /* Arrange groups vertically */
        gap: 10px;
        border-bottom: 1px solid #3a3a3a;
      }

      #listToggleButton {
        position: absolute;
        top: 50%;
        left: 10px; /* Will be adjusted via JS */
        transform: translateY(-50%);
        background: rgba(58,58,58,0.95);
        color: white;
        border: none;
        padding: 10px 8px;
        cursor: pointer;
        z-index: 11;
        border-radius: 6px;
        font-size: 1.1em;
      }

      #listToggleButton.hidden {
        border-radius: 6px;
      }

    .video-js {
      width: 100%;
      height: 100%;
    }

    .item {
      padding: 12px 15px;
      border-bottom: 1px solid #333;
      cursor: pointer;
      transition: background-color 0.2s ease;
      font-size: 0.95em;
    }

    .item:last-child {
      border-bottom: none;
    }

    .item:hover {
      background: #3a3a3a;
    }

    .item.active {
      background: #505050;
      outline: 2px solid #7aa7ff;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      #controls {
        flex-direction: column;
        align-items: stretch;
      }

      #playlistUrlInput,
      #loadPlaylistBtn,
      #categoryFilter,
      #languageFilter {
        width: 100%;
        min-width: unset;
      }
    }
  </style>
</head>
<body>
<div id="main-content">
  <div id="controls">
    <div class="input-group">
      <input type="text" id="playlistUrlInput" placeholder="Enter M3U playlist URL">
      <button id="loadPlaylistBtn">Load Playlist</button>
    </div>
    <div class="filter-group">
      <select id="categoryFilter">
        <option value="all">All Categories</option>
      </select>
      <!-- <select id="languageFilter" multiple>
        <option value="all">All Languages</option>
      </select> -->
    </div>
  </div>

  <div id="player-container">
    <video id="video" class="video-js vjs-default-skin vjs-big-play-centered" controls preload="auto" data-setup='{}'></video>
    <!-- Floating channel list & toggle lives INSIDE player container -->
    <div id="list"></div>
    <button id="listToggleButton">&#9664;</button>
    <div id="epgOverlay" style="display:none"></div>
  </div>
</div>

<script>
  const urlParams = new URLSearchParams(window.location.search);
  const playlistUrlFromParams = urlParams.get("url");
  const epgUrlFromParams = urlParams.get("epg"); // optional XMLTV URL
  const proxyBaseFromParams = urlParams.get("proxy"); // optional: proxy all HLS requests
  const playlistUrlInput = document.getElementById("playlistUrlInput");
  const loadPlaylistBtn = document.getElementById("loadPlaylistBtn");
  const listDiv = document.getElementById("list");
  const listToggleButton = document.getElementById("listToggleButton");
  const mainContent = document.getElementById("main-content");

  let player = videojs('video');
  player.hlsQualitySelector();
  const zoomPlugin = player.zoomPlugin();

  // Keep an hls.js instance for fallback when VHS fails
  let hlsInstance = null;
  let lastTriedUrl = null;
  let lastBaseStreamUrl = null; // original (maybe-https-upgraded) url without applied proxy
  let currentProxyBase = proxyBaseFromParams || null;
  const triedProxyBases = new Set(currentProxyBase ? [currentProxyBase] : []);
  const DEFAULT_PROXY_CANDIDATES = [
    // User's Cloudflare Worker proxy (prioritized) – template style
    'https://jolly-bonus-cab5.2e0fed7d-4ff6-4935-a061-96106fbf6b04.workers.dev/?u={url}',
    // Prefix style: append URL directly
    'https://cors.isomorphic-git.org/',
    // Template style: place URL after ?
    'https://corsproxy.io/?{url}',
    // Template style: place URL after /fetch/
    'https://thingproxy.freeboard.io/fetch/{url}'
  ];

  // Remote/keyboard navigation state
  let currentList = [];
  let selectedIndex = 0;
  function updateActiveItem() {
    const items = listDiv.querySelectorAll('.item');
    items.forEach((el, i) => {
      if (i === selectedIndex) {
        el.classList.add('active');
        // ensure visibility
        el.scrollIntoView({ block: 'nearest' });
      } else {
        el.classList.remove('active');
      }
    });
  }
  function selectIndex(i) {
    if (!currentList.length) return;
    if (i < 0) i = 0;
    if (i >= currentList.length) i = currentList.length - 1;
    selectedIndex = i;
    updateActiveItem();
  }

  function setStatus(msg, isError = false) {
    let bar = document.getElementById('statusBar');
    if (!bar) {
      bar = document.createElement('div');
      bar.id = 'statusBar';
      bar.style.cssText = 'padding:8px 12px;background:#222;color:#ddd;border-top:1px solid #333;font-size:0.9em;';
      document.getElementById('controls').appendChild(bar);
    }
    bar.style.color = isError ? '#ffb4b4' : '#ddd';
    bar.textContent = msg || '';
  }

  function updateTogglePosition() {
    if (listDiv.classList.contains("hidden")) {
      listToggleButton.style.left = "10px";
    } else {
      const left = 10 + listDiv.offsetWidth + 8; // panel + gap
      listToggleButton.style.left = left + "px";
    }
  }

  listToggleButton.addEventListener("click", () => {
    listDiv.classList.toggle("hidden");
    if (listDiv.classList.contains("hidden")) {
      listToggleButton.innerHTML = "&#9654;"; // Right arrow
    } else {
      listToggleButton.innerHTML = "&#9664;"; // Left arrow
    }
    updateTogglePosition();
  });

  // Initial position for toggle button next to visible list
  updateTogglePosition();
  window.addEventListener("resize", updateTogglePosition);


  if (playlistUrlFromParams) {
    playlistUrlInput.value = playlistUrlFromParams;
    loadM3U(playlistUrlFromParams);
  }

  // Load EPG if provided
  let epgData = null; // { map: Map<tvgId, programmes[]> }
  if (epgUrlFromParams) {
    loadEPG(epgUrlFromParams).catch(() => {});
  }

  loadPlaylistBtn.addEventListener("click", () => {
    const url = playlistUrlInput.value;
    if (url) {
      loadM3U(url);
    } else {
      alert("Please enter a playlist URL.");
    }
  });

  async function loadM3U(url) {
    if (!url) {
      document.body.innerHTML = "<h2 style='padding:20px;'>No playlist URL provided.</h2>";
      throw new Error("No playlist URL provided");
    }
    // Try direct fetch first; if blocked, retry via proxy
    let text = '';
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Playlist fetch failed: ' + res.status);
      text = await res.text();
    } catch (e) {
      // Apply current proxy or fallbacks for playlist file
      setStatus('Playlist fetch blocked, retrying via proxy…', true);
      // Prime proxy candidates
      if (!currentProxyBase) { tryNextProxyBase(); }
      const proxiedPlaylistUrl = applyProxy(url);
      try {
        const res2 = await fetch(proxiedPlaylistUrl);
        if (!res2.ok) throw new Error('Proxied playlist fetch failed: ' + res2.status);
        text = await res2.text();
      } catch (e2) {
        setStatus('Unable to load playlist (CORS/geo/offline).', true);
        throw e2;
      }
    }
    const lines = text.split("\n");

    let channels = [];
    let current = {};
    const categories = new Set();
    const languages = new Set();

    lines.forEach(line => {
      line = line.trim();

      if (line.startsWith("#EXTINF")) {
        const nameMatch = line.match(/,(.*)$/);
        const groupTitleMatch = line.match(/group-title="([^"]*)"/);
        const tvgLanguageMatch = line.match(/tvg-language="([^"]*)"/);
        const tvgIdMatch = line.match(/tvg-id="([^"]*)"/);

        current = {
          name: nameMatch ? nameMatch[1] : "Unknown",
          category: groupTitleMatch ? groupTitleMatch[1] : "Others",
          language: tvgLanguageMatch ? tvgLanguageMatch[1] : "Unknown",
          tvgId: tvgIdMatch ? tvgIdMatch[1] : null
        };
        categories.add(current.category);
        languages.add(current.language);
      } else if (line.startsWith("http")) {
        current.url = line;
        channels.push(current);
      }
    });

    // Store all channels and unique categories/languages globally or pass them
    window.allChannels = channels;
    window.uniqueCategories = Array.from(categories).sort();

    populateCategoryFilter(window.uniqueCategories);
    applyFilters();
  }

  function populateCategoryFilter(categories) {
    const categoryFilter = document.getElementById("categoryFilter");
    categoryFilter.innerHTML = ''; // Clear existing options
    const allOption = document.createElement("option");
    allOption.value = "all";
    allOption.textContent = "All Categories";
    allOption.selected = true; // Select "All Categories" by default
    categoryFilter.appendChild(allOption);

    categories.forEach(category => {
      const option = document.createElement("option");
      option.value = category;
      option.textContent = category;
      categoryFilter.appendChild(option);
    });
  }



  function applyFilters() {
    const selectedCategory = document.getElementById("categoryFilter").value;
    let filteredChannels = window.allChannels;

    if (selectedCategory !== "all") {
      filteredChannels = filteredChannels.filter(ch => ch.category === selectedCategory);
    }
    displayChannels(filteredChannels);
  }

  document.getElementById("categoryFilter").addEventListener("change", () => {
    applyFilters();
  });

  function displayChannels(channelsToDisplay) {
    const listDiv = document.getElementById("list");
    listDiv.innerHTML = ''; // Clear existing list

    if (channelsToDisplay.length === 0) {
      listDiv.innerHTML = '<p style="padding: 10px;">No channels found for the selected filters.</p>';
      return;
    }

    currentList = channelsToDisplay.slice();
    selectedIndex = 0;
    channelsToDisplay.forEach((ch, idx) => {
      const div = document.createElement("div");
      div.className = "item";
      div.textContent = ch.name;
      div.setAttribute('tabindex', '0');

      div.onclick = () => {
        playStreamWithFallback(ch.url, ch.name, ch.tvgId);
      };

      listDiv.appendChild(div);
    });

    if (channelsToDisplay.length > 0) {
      const first = channelsToDisplay[0];
      playStreamWithFallback(first.url, first.name, first.tvgId);
      updateActiveItem();
    }
  }

  function cleanupHls() {
    if (hlsInstance) {
      try { hlsInstance.destroy(); } catch(e) {}
      hlsInstance = null;
    }
  }

  function getVideoElement() {
    // underlying HTML5 <video> element used by video.js
    const tech = player.tech(true);
    return tech && tech.el ? tech.el() : document.getElementById('video');
  }

  function maybeUpgradeToHttps(url) {
    if (location.protocol === 'https:' && url.startsWith('http://')) {
      return 'https://' + url.substring('http://'.length);
    }
    return url;
  }

  function applyProxy(url) {
    if (!currentProxyBase) return url;
    // Avoid double-proxying: if url already points to a known proxy, return as-is
    const lower = url.toLowerCase();
    const isAlreadyProxied = (
      lower.includes('.workers.dev/?u=') ||
      lower.includes('cors.isomorphic-git.org/') ||
      lower.includes('corsproxy.io/?') ||
      lower.includes('thingproxy.freeboard.io/fetch/')
    );
    if (isAlreadyProxied) return url;

    // Template replacement
    if (currentProxyBase.includes('{url}')) {
      const encoded = encodeURIComponent(url);
      return currentProxyBase.replace('{url}', encoded);
    }
    // If ends with '?', append encoded url after '?'
    if (currentProxyBase.endsWith('?')) {
      return currentProxyBase + encodeURIComponent(url);
    }
    // If ends with '/fetch/' like thingproxy, append url raw
    if (currentProxyBase.endsWith('/fetch/')) {
      return currentProxyBase + url;
    }
    // Fallback: prefix style
    return currentProxyBase + url;
  }

  function tryNextProxyBase() {
    // If a proxy is already set via query, don't override; but if it fails, also try our defaults
    for (const candidate of DEFAULT_PROXY_CANDIDATES) {
      if (!triedProxyBases.has(candidate)) {
        triedProxyBases.add(candidate);
        currentProxyBase = candidate;
        return true;
      }
    }
    return false;
  }

  // Retry tracking for the same channel, no auto-skip
  let retryCount = 0;
  const MAX_RETRIES_PER_PROXY = 2;

  function playWithVJS(url) {
    cleanupHls();
    const type = detectMimeForUrl(url);
    player.src({ type, src: url });
    const onError = () => {
      player.off('error', onError);
      setStatus('Primary player failed, trying fallback…', true);
      playWithHlsJs(url);
    };
    player.one('error', onError);
    player.play().catch(() => {});
  }

  function playWithHlsJs(url) {
    cleanupHls();
    if (window.Hls && window.Hls.isSupported()) {
      const videoEl = getVideoElement();
      // Custom loader to proxy nested requests when proxy param is provided
      const proxyBase = currentProxyBase || '';
      const CustomLoader = (proxyBase
        ? class extends window.Hls.DefaultConfig.loader {
            constructor(config) { super(config); this._proxyBase = proxyBase; }
            load(context, config, callbacks) {
              try {
                const original = context.url;
                if (this._proxyBase) {
                  const proxied = this._proxyBase.includes('{url}')
                    ? this._proxyBase.replace('{url}', encodeURIComponent(original))
                    : this._proxyBase + original;
                  context.url = proxied;
                }
              } catch (e) {}
              super.load(context, config, callbacks);
            }
          }
        : window.Hls.DefaultConfig.loader
      );

      hlsInstance = new window.Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 90,
        fragLoadTimeout: 20000,
        manifestLoadTimeout: 20000,
        xhrSetup: function(xhr) {
          // credentials often not needed; leave disabled by default
          xhr.withCredentials = false;
          // cannot set Referer/Origin headers in browsers
        },
        loader: CustomLoader
      });
      hlsInstance.attachMedia(videoEl);
      hlsInstance.on(window.Hls.Events.MEDIA_ATTACHED, () => {
        hlsInstance.loadSource(url);
      });
      hlsInstance.on(window.Hls.Events.MANIFEST_PARSED, () => {
        player.play().catch(() => {});
      });
      hlsInstance.on(window.Hls.Events.ERROR, function (event, data) {
        const { fatal, type, details } = data || {};
        if (fatal) {
          switch (data.type) {
            case window.Hls.ErrorTypes.NETWORK_ERROR:
              setStatus('Network error loading stream (CORS/geo/offline?)', true);
              // Attempt CORS-proxied retry if we haven't already
              if (tryNextProxyBase() && lastBaseStreamUrl) {
                setStatus('Retrying via CORS proxy…');
                try { hlsInstance.destroy(); } catch(e) {}
                hlsInstance = null;
                // Re-run with proxied base URL
                const proxied = applyProxy(lastBaseStreamUrl);
                playWithHlsJs(proxied);
              } else {
                // No more proxies to try; attempt limited Hls.js reloads on the same channel
                if (retryCount < MAX_RETRIES_PER_PROXY) {
                  retryCount++;
                  setStatus('Retrying same channel (' + retryCount + '/' + MAX_RETRIES_PER_PROXY + ')…', true);
                  try { hlsInstance.destroy(); } catch(e) {}
                  hlsInstance = null;
                  playWithHlsJs(applyProxy(lastBaseStreamUrl));
                } else {
                  setStatus('Stream blocked or offline. This player cannot bypass server restrictions.', true);
                }
              }
              break;
            case window.Hls.ErrorTypes.MEDIA_ERROR:
              setStatus('Media error, attempting recovery…', true);
              try { hlsInstance.recoverMediaError(); } catch(e) {}
              break;
            default:
              setStatus('Fatal error: ' + (type || details || 'unknown'), true);
              try { hlsInstance.destroy(); } catch(e) {}
              hlsInstance = null;
              break;
          }
        }
      });
    } else {
      setStatus('Hls.js not supported in this browser.', true);
    }
  }

  function detectMimeForUrl(url) {
    const u = url.toLowerCase();
    if (u.includes('.m3u8')) return 'application/x-mpegURL';
    if (u.endsWith('.mp4')) return 'video/mp4';
    if (u.endsWith('.ts')) return 'video/mp2t';
    // Heuristic: IP:port with no path often serves MPEG-TS
    if (/^https?:\/\/\d+\.\d+\.\d+\.\d+:\d+\/?$/.test(u)) return 'video/mp2t';
    // default to HLS; if it fails, fallback will engage
    return 'application/x-mpegURL';
  }

  function playStreamWithFallback(originalUrl, channelName, tvgId) {
    lastTriedUrl = originalUrl;
    setStatus('Loading: ' + (channelName || originalUrl));
    // Try to mitigate mixed-content by upgrading http→https when page is https
    let url = maybeUpgradeToHttps(originalUrl);
    // Apply optional proxy for all loads (master + segments)
    lastBaseStreamUrl = url; // keep before applying proxy
    // Reset proxy state per new channel unless fixed via query param
    currentProxyBase = proxyBaseFromParams || null;
    triedProxyBases.clear();
    if (currentProxyBase) triedProxyBases.add(currentProxyBase);
    url = applyProxy(url);

    // First try Video.js/VHS
    playWithVJS(url);

    // Update EPG overlay for selected channel
    updateEpgOverlay(tvgId);
  }

  // Global key handler for TV/remote/keyboard
  // Common keys: ArrowUp/Down/Left/Right, Enter, NumpadEnter, PageUp/PageDown, ChannelUp/ChannelDown
  document.addEventListener('keydown', (e) => {
    const key = e.key;
    switch (key) {
      case 'ArrowDown':
        e.preventDefault();
        selectIndex(selectedIndex + 1);
        break;
      case 'ArrowUp':
        e.preventDefault();
        selectIndex(selectedIndex - 1);
        break;
      case 'PageDown':
        e.preventDefault();
        selectIndex(selectedIndex + 10);
        break;
      case 'PageUp':
        e.preventDefault();
        selectIndex(selectedIndex - 10);
        break;
      case 'Enter':
      case 'NumpadEnter':
        e.preventDefault();
        if (currentList[selectedIndex]) {
          const ch = currentList[selectedIndex];
          playStreamWithFallback(ch.url, ch.name);
        }
        break;
      case 'ArrowLeft':
        // toggle list visibility
        e.preventDefault();
        listDiv.classList.toggle('hidden');
        listToggleButton.innerHTML = listDiv.classList.contains('hidden') ? '&#9654;' : '&#9664;';
        updateTogglePosition();
        break;
      case 'ArrowRight':
        // no-op for now
        break;
      default:
        // Some TVs map channel keys to non-standard names. Try keyCode fallback
        if (e.keyCode === 427) { // ChannelUp
          e.preventDefault();
          selectIndex(selectedIndex - 1);
        } else if (e.keyCode === 428) { // ChannelDown
          e.preventDefault();
          selectIndex(selectedIndex + 1);
        } else if (e.keyCode === 13) { // Enter
          e.preventDefault();
          if (currentList[selectedIndex]) {
            const ch = currentList[selectedIndex];
            playStreamWithFallback(ch.url, ch.name);
          }
        }
        break;
    }
  }, { capture: true });

  // =====================
  // EPG support (client)
  // =====================
  async function loadEPG(epgUrl) {
    setStatus('Loading EPG…');
    let xmlText = '';
    try {
      const r = await fetch(epgUrl);
      if (!r.ok) throw new Error('EPG fetch failed: ' + r.status);
      xmlText = await r.text();
    } catch (e) {
      // Try via proxy
      setStatus('EPG blocked, retrying via proxy…', true);
      if (!currentProxyBase) { tryNextProxyBase(); }
      const proxied = applyProxy(epgUrl);
      const r2 = await fetch(proxied);
      if (!r2.ok) throw new Error('EPG proxied fetch failed: ' + r2.status);
      xmlText = await r2.text();
    }
    epgData = parseXMLTV(xmlText);
    setStatus('EPG loaded');
  }

  function parseXMLTV(xmlText) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlText, 'application/xml');
    const progs = doc.querySelectorAll('programme');
    const map = new Map(); // tvgId -> [{start, stop, title, desc}]
    progs.forEach(p => {
      const channel = p.getAttribute('channel');
      const start = parseXmltvDate(p.getAttribute('start'));
      const stop = parseXmltvDate(p.getAttribute('stop'));
      const title = (p.querySelector('title')?.textContent || '').trim();
      const desc = (p.querySelector('desc')?.textContent || '').trim();
      if (!channel || !start || !stop) return;
      if (!map.has(channel)) map.set(channel, []);
      map.get(channel).push({ start, stop, title, desc });
    });
    // sort each by start
    for (const arr of map.values()) arr.sort((a,b)=>a.start-b.start);
    return { map };
  }

  function parseXmltvDate(s) {
    if (!s) return null;
    const m = s.match(/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(?:\s?([+\-]\d{4}))?/);
    if (!m) return null;
    const [,Y,M,D,h,mn,ss,off] = m;
    const iso = `${Y}-${M}-${D}T${h}:${mn}:${ss}` + (off ? `${off.substring(0,3)}:${off.substring(3)}` : 'Z');
    const d = new Date(iso);
    return isNaN(d.getTime()) ? null : d;
  }

  function hhmm(d) {
    const hh = `${d.getHours()}`.padStart(2,'0');
    const mm = `${d.getMinutes()}`.padStart(2,'0');
    return `${hh}:${mm}`;
  }

  function updateEpgOverlay(tvgId) {
    const overlay = document.getElementById('epgOverlay');
    if (!epgData || !tvgId || !epgData.map.has(tvgId)) {
      overlay.style.display = 'none';
      return;
    }
    const list = epgData.map.get(tvgId);
    const now = new Date();
    let nowProg = null, nextProg = null;
    for (let i=0;i<list.length;i++) {
      const p = list[i];
      if (p.start <= now && now < p.stop) {
        nowProg = p;
        nextProg = list[i+1] || null;
        break;
      }
      if (p.start > now) { nextProg = p; break; }
    }
    if (!nowProg && list.length) {
      // if all past, show last as now
      nowProg = list.find(p=>p.stop>now) || list[list.length-1];
    }
    const parts = [];
    if (nowProg) {
      parts.push(`<span class="title">Now:</span> ${escapeHtml(nowProg.title||'')} <span class="time">(${hhmm(nowProg.start)}–${hhmm(nowProg.stop)})</span>`);
    }
    if (nextProg) {
      parts.push(`<span class="sep">|</span><span class="title">Next:</span> ${escapeHtml(nextProg.title||'')} <span class="time">(${hhmm(nextProg.start)}–${hhmm(nextProg.stop)})</span>`);
    }
    overlay.innerHTML = parts.join(' ');
    overlay.style.display = parts.length ? 'block' : 'none';
  }

  function escapeHtml(s){
    return (s||'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]))
  }

  // Refresh EPG overlay every minute
  setInterval(()=>{
    const active = currentList[selectedIndex];
    if (active) updateEpgOverlay(active.tvgId);
  }, 60000);

</script>

</body>
</html>
